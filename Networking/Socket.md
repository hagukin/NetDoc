
### 소켓 입출력 버퍼  
소켓을 사용해 데이터를 보내줄 때는 클라이언트측 코드상에서 잡아놓은 메모리 내 버퍼에서 서버측 코드상에서 잡아놓은 메모리 내 버퍼로 바로 보내지는 것이 아니다.  
전송 과정에서 커널을 커치는데, 커널에서는 소켓이 생성될 때 RecvBuffer와 SendBuffer라는 공간을 만들어둔다.  
클라에서 ::send()를 통해 버퍼를 보내면 이 값이 바로 서버측 버퍼로 넘어가는 게 아닌, 클라측 커널의 SendBuffer에 저장되었다가 나중에 커널이 이걸 받는쪽 커널의 RecvBuffer로 이동시켜주는 것이다.  
::recv()도 마찬가지로 내 커널의 RecvBuffer에 들어있는 값들을 전부 읽어오는 것이지, 클라에서 보낸 버퍼와 1대1로 상호적으로 동작하는 게 아니다.  

이 사실을 이해해야 아래의 몇가지 중요한 현상들을 이해할 수 있다.  

IOCP 39 참고

### send()와 recv()는 blocking 함수인데 왜 blocking이 안되지?  
사전지식: 소켓 입출력 버퍼  
클라에서 send()해주고 서버에서는 recv() 안한 채 딴 짓만 하고 있다고 가정해보자.  
그리고 동시에 코드상에서 send()가 에러가 나지 않으면 "Send successful"이라는 로그를 띄운다고 가정해보자.  
이 경우 어떤 일이 일어날까?  

send()와 recv()는 blocking 함수인데, 때문에 자칫 "서버에서 recv를 안했으므로 클라측 코드에서 send 지점에서 멈춰 코드가 더 진행되지 않을 것이다"라고 생각하기 쉽다.  
그러나 실제로는 "Send successful"이 뜨는 것을 볼 수 있는데, 그 이유는  
send()는 분명 blocking 함수이나, send는 어디까지나 커널단의 입출력 버퍼인 SendBuffer로 데이터를 보내주는 역할만 해주기 때문이다!  
고로 서버측에서는 아무 데이터도 받지 못했지만 send()가 통과되어 로그가 찍히는 것이다.  

IOCP 39 참고  

### WSASend() 등의 비동기 함수들에 대하여
앞으로 IOCP 모델에서 사용될 WSASend, WSARecv등의 함수들은 일반적인 블로킹함수인 Send, Recv와는 다른데, 
WSA함수들은 논블로킹 소켓에서 작동하며 실행 즉시 완료 여부와 관계없이 결과를 반환한다.  
[참고글](https://z-man.tistory.com/272)  
[참고글2](https://1d1cblog.tistory.com/385)  
  
### TCP의 성질과 관련된 recv()의 특성  
클라가 크기 100짜리 데이터를 TCP로 서버에게 보낸다고 가정하자.  
또 서버측 RecvBuffer의 크기가 1000이라고 가정하자.  
send()를 10번 해주면 총 1000만큼의 데이터가 전송될 것이다.  
서버에서 클라가 데이터를 10번 보낸 이후 recv()를 해주면 이 1000만큼의 데이터가 한 번에 받아질 것이고, 받은 데이터의 크기를 반환하는 recv()함수는 1000을 반환할 것이다.  

즉, TCP는 패킷 간의 구분 없이 데이터를 전송한다.  

이번에는 서버측 RecvBuffer가 950이라고 가정하자.  
위와 동일한 상황 (클라가 10번 전송 후 서버가 recv)에서 과연 어떻게 될까?  
recv()는 950을 반환할 것이다. (=서버는 950만큼의 데이터를 받는다)  
그 후 다시 recv()를 하면 50을 반환할 것이다.  
즉, 10번째 패킷이 50,50으로 쪼개진 것을 알 수 있는데 이 또한 TCP의 성질이다.  

IOCP 39 참고  

위와 반대로 UDP의 경우 패킷 간의 바운더리가 명확하다. 고로 위와 같은 상황에서 sendto() (UDP는 send대신 sendto를 사용)를 10번 호출해 100씩 10번 보냈을 경우,  
서버측에서 recvfrom() (recv대신 사용)을 할 때 한 번에 1000이 읽히는 TCP와 달리 100씩 읽어온다.  
(참고: UDP도 connected UDP, 즉 소켓에 발신에 항상 사용할 상대방 주소를 저장해놓는 UDP의 경우 connect()와 send()를 사용한다. 물론 TCP처럼 진짜 connection이 형성되는 건 아니고, 그냥 sendto 호출할때마다 인자로 주소를 넘겨주는 걸 편하게 해주는 용도 정도이다. sendto()를 사용하는 UDP는 unconnected UDP라고 한다. IOCP 41 참고)  

### 소켓의 주소 재사용
tcp에서 소켓에는 아이피와 포트가 바인딩되는데, 만약 모종의 이유로 이 소켓을 제거하지 않은 채로 프로그램이 종료되었고, 다시 실행하려 한다고 해보자. 똑같이 소켓은 같은 주소와 포트를 잡으려 할 텐데, 이미 이전 실행에서 해당 포트를 점유했기 때문에 바인딩이 안되는 문제가 발생한다.  
이를 해결하기 위해 winapi의 setsocketopt에서 SO_REUSEADDR 옵션을 사용해 강제로 포트를 뺏어오도록 만들 수 있다. (iocp 42)  

### Blocking vs Non-Blocking  
Blocking 소켓은 accept 실행시 접속한 클라가 있을 때 진행되고, connect는 서버 접속에 성공했을때 진행되고, 이런식으로 뭔가가 완료가 될 때까지 대기하는 형태로 로직을 처리한다.  
이건 멀티플레이어 게임에서는 당연히 문제가 발생할 수 밖에 없다. 물론 스레드를 클라이언트 갯수만큼 늘릴 수도 있겠지만, 그러기엔 클라 수가 늘어날 수록 콘텍스트 스위칭 비용이 너무 증가한다는 문제가 있다.  

winsock에서는 ioctlsocket()함수를 이용해 논블로킹 소켓으로 전환시켜줄 수 있다.  

무조건 논블로킹으로 바꾼다고 성능 향상이 되는 것은 아니다. while loop으로 cpu 사이클 낭비하면서 직접 매번 체크해주는 것보다 그냥 블로킹으로 제대로 된 처리가 될 때까지 블록해주는 게 더 빠를 수도 있다. 게다가 논블로킹 상황에서는 다양한 예외처리를 해줘야 하기 때문에 코드가 난잡해질 수 있다는 문제가 있다. (iocp 43)  

그럼 어떻게 해야 할까?  
이런 문제를 해결하고 보다 효율적인 처리를 할 수 있도록 소켓을 구성해놓은 것을 소켓 모델이라고 한다.  

### 소켓 모델  
별도 문서로 이동


참고: 소켓 함수의 라이브러리화에 대해서는 iocp Socket utils 참고  
