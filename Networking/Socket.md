
### 소켓 입출력 버퍼  
소켓을 사용해 데이터를 보내줄 때는 클라이언트측 코드상에서 잡아놓은 메모리 내 버퍼에서 서버측 코드상에서 잡아놓은 메모리 내 버퍼로 바로 보내지는 것이 아니다.  
전송 과정에서 커널을 커치는데, 커널에서는 소켓이 생성될 때 RecvBuffer와 SendBuffer라는 공간을 만들어둔다.  
클라에서 ::send()를 통해 버퍼를 보내면 이 값이 바로 서버측 버퍼로 넘어가는 게 아닌, 클라측 커널의 SendBuffer에 저장되었다가 나중에 커널이 이걸 받는쪽 커널의 RecvBuffer로 이동시켜주는 것이다.  
::recv()도 마찬가지로 내 커널의 RecvBuffer에 들어있는 값들을 전부 읽어오는 것이지, 클라에서 보낸 버퍼와 1대1로 상호적으로 동작하는 게 아니다.  

이 사실을 이해해야 아래의 몇가지 중요한 현상들을 이해할 수 있다.  

IOCP 39 참고

### send()와 recv()는 blocking 함수인데 왜 blocking이 안되지?  
사전지식: 소켓 입출력 버퍼  
클라에서 send()해주고 서버에서는 recv() 안한 채 딴 짓만 하고 있다고 가정해보자.  
그리고 동시에 코드상에서 send()가 에러가 나지 않으면 "Send successful"이라는 로그를 띄운다고 가정해보자.  
이 경우 어떤 일이 일어날까?  

send()와 recv()는 blocking 함수인데, 때문에 자칫 "서버에서 recv를 안했으므로 클라측 코드에서 send 지점에서 멈춰 코드가 더 진행되지 않을 것이다"라고 생각하기 쉽다.  
그러나 실제로는 "Send successful"이 뜨는 것을 볼 수 있는데, 그 이유는  
send()는 분명 blocking 함수이나, send는 어디까지나 커널단의 입출력 버퍼인 SendBuffer로 데이터를 보내주는 역할만 해주기 때문이다!  
고로 서버측에서는 아무 데이터도 받지 못했지만 send()가 통과되어 로그가 찍히는 것이다.  

IOCP 39 참고  
  
### TCP의 성질과 관련된 recv()의 특성  
클라가 크기 100짜리 데이터를 TCP로 서버에게 보낸다고 가정하자.  
또 서버측 RecvBuffer의 크기가 1000이라고 가정하자.  
send()를 10번 해주면 총 1000만큼의 데이터가 전송될 것이다.  
서버에서 클라가 데이터를 10번 보낸 이후 recv()를 해주면 이 1000만큼의 데이터가 한 번에 받아질 것이고, 받은 데이터의 크기를 반환하는 recv()함수는 1000을 반환할 것이다.  

즉, TCP는 패킷 간의 구분 없이 데이터를 전송한다.  

이번에는 서버측 RecvBuffer가 950이라고 가정하자.  
위와 동일한 상황 (클라가 10번 전송 후 서버가 recv)에서 과연 어떻게 될까?  
recv()는 950을 반환할 것이다. (=서버는 950만큼의 데이터를 받는다)  
그 후 다시 recv()를 하면 50을 반환할 것이다.  
즉, 10번째 패킷이 50,50으로 쪼개진 것을 알 수 있는데 이 또한 TCP의 성질이다.  

IOCP 39 참고  

위와 반대로 UDP의 경우 패킷 간의 바운더리가 명확하다. 고로 위와 같은 상황에서 sendto() (UDP는 send대신 sendto를 사용)를 10번 호출해 100씩 10번 보냈을 경우,  
서버측에서 recvfrom() (recv대신 사용)을 할 때 한 번에 1000이 읽히는 TCP와 달리 100씩 읽어온다.  
(참고: UDP도 connected UDP, 즉 소켓에 발신에 항상 사용할 상대방 주소를 저장해놓는 UDP의 경우 connect()와 send()를 사용한다. 물론 TCP처럼 진짜 connection이 형성되는 건 아니고, 그냥 sendto 호출할때마다 인자로 주소를 넘겨주는 걸 편하게 해주는 용도 정도이다. sendto()를 사용하는 UDP는 unconnected UDP라고 한다. IOCP 40 참고)  

