## 논블로킹 소켓을 사용해 소켓 통신을 구축하는 모델들  

### Select 모델  
Select 함수가 핵심이 되는 소켓 모델이다.  
주 아이디어는 소켓 함수(recv등)의 호출했을 때 성공할 수 있는지를 미리 알 수 있다는 것이다.  
소켓 셋(일종의 소켓 배열)을 이용하는데, read, write 두 개의 소켓 셋(정확히는 예외적인 상황들을 담당하는 exception까지 세 개이지만 거의 두 개만이 사용된다)을 만들고 select()에 이 세트들을 넘기면 select는 각 소켓 셋 속에 들어있는 소켓들이 지금 시점에서 read/write를 처리할 수 있는지를 판단하고, 가능한 소켓들만 set에 남기고 아닌 소켓들을 지운 후 남은 소켓들의 갯수를 반환한다.  
이후 어떤 특정 소켓이 read또는 write가 가능한지 확인하고, 가능할 경우 해당 동작(ex. recv())을 처리해주면 된다.  
다행히 이걸 직접 비트필드를 활용해 구현해줄 필요는 없고, 윈도우에서 제공하는 기능을 사용하면 된다.  

사실 아직까지 얼마만큼의 성능상의 차이가 있는지는 모르겠다. 다만 코드의 구조가 훨씬 깔끔해지는 건 확실하다.  
단점도 존재하는데, 소켓 셋 속에 들어갈 수 있는 소켓의 최대 갯수가 윈도우 기준으로 64개까지 가능한데, 때문에 64명 이상의 클라이언트를 받으려면 소켓 셋을 그만큼 많이 사용해야 한다.  

(IOCP 44 참고)  
