## 논블로킹 소켓을 사용해 소켓 통신을 구축하는 모델들  

### Select 모델  
Select 함수가 핵심이 되는 소켓 모델이다.  
주 아이디어는 소켓 함수(recv등)의 호출했을 때 성공할 수 있는지를 미리 알 수 있다는 것이다.  
소켓 셋(일종의 소켓 배열)을 이용하는데, read, write 두 개의 소켓 셋(정확히는 예외적인 상황들을 담당하는 exception까지 세 개이지만 거의 두 개만이 사용된다)을 만들고 select()에 이 세트들을 넘기면 select는 각 소켓 셋 속에 들어있는 소켓들이 지금 시점에서 read/write를 처리할 수 있는지를 판단하고, 가능한 소켓들만 set에 남기고 아닌 소켓들을 지운 후 남은 소켓들의 갯수를 반환한다.  
이후 어떤 특정 소켓이 read또는 write가 가능한지 확인하고, 가능할 경우 해당 동작(ex. recv())을 처리해주면 된다.  
다행히 이걸 직접 비트필드를 활용해 구현해줄 필요는 없고, 윈도우에서 제공하는 기능을 사용하면 된다.  

사실 아직까지 얼마만큼의 성능상의 차이가 있는지는 모르겠다. 다만 코드의 구조가 훨씬 깔끔해지는 건 확실하다.  
단점도 존재하는데, 소켓 셋 속에 들어갈 수 있는 소켓의 최대 갯수가 윈도우 기준으로 64개까지 가능한데, 때문에 64명 이상의 클라이언트를 받으려면 소켓 셋을 그만큼 많이 사용해야 한다.  

(IOCP 44 참고)  

### WSAEventSelect 모델  
소켓에서 발생하는 네트워크 이벤트를 **이벤트 객체** 를 통해 파악하는 방식.  
```c++
WSAEventSelect(소켓, 네트워크 이벤트 감지를 위해 소켓과 연동된 이벤트 객체, 감지할 이벤트의 종류(들));
// Tip: 감지할 이벤트의 종류는 long인자 하나를 받는데, 이때 여러 이벤트를 다 감지하고 싶으면 long var = FD_ACCEPT | FD_CLOSE; 식으로 비트연산을 활용해 long을 만들고 넘겨주면 된다.  

WSAWaitForMultipleEvents(...);
// select 모델의 select함수와 매우 유사함, 이벤트들의 목록 중에서 네트워크 이벤트가 처리된 이벤트의 인덱스를 반환한다. (정확히는 이벤트 인덱스에 약간 변형을 한 값이지만 이 값에서 index를 추출할 수 있음)
// 앞서 말했듯이 감지할 이벤트의 종류를 여러 개 넘겨줄 수 있으므로, WSAWaitForMultipleEvents()가 네트워크 이벤트가 실행된 이벤트의 인덱스를 반환하더라도 정확히 어떤 네트워크 이벤트가 실행되었는지를 모를 수 있음. 
// 이를 해결하기 위한 게 바로 WSAEnumNetworkEvents()임.

WSAEnumNetworkEvents(...);
// 소켓에서 정확히 어떤 네트워크 이벤트가 실행되었는 지 반환함
```
Select 모델과 거의 유사한 흐름으로 진행되며 예제 코드를 보면 쉽게 이해할 수 있음.  
매 루프마다 소켓셋을 초기화해줘야 했던 select와 다르게 한 번 이벤트들을 만들어놓으면 계속 사용할 수 있다.  
다만 소켓셋에 갯수 제한이 있었던 것처럼 한 번에 주시할 수 있는 이벤트의 최대 갯수도 제한이 있다.  
(필요하면 더 만들면 된다. 그러나 이게 복잡해지기 때문에 IOCP를 사용하는 것.)  
(IOCP 45 참고)

