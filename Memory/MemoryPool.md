# Memory Pool
## 개요
메모리 풀링은 말 그대로 일정량의 메모리를 미리 할당해놓은 이후 필요할 때 그 덩어리의 일부분을 나눠주는 식으로 메모리를 관리하는 방식을 의미한다.  

## 구현
세부적인 내용은 IOCP 32 참고  
주로 사용되는 정책은 여러 개의 메모리 풀 오브젝트를 만들고 각각의 오브젝트가 서로 다른 크기를 관리하도록 하는 것이다.  
쉽게 말해 x라는 메모리가 필요할 때, x가 32 이하면 A라는 메모리풀에서 가져오고, 64면 B, 96이면 C, ... 이런 식으로 필요한 영역에 따라 다른 메모리풀에게 메모리를 요청하는 것이다.  
(32,64,96 이런 식으로 각 메모리풀의 allocSize를 얼마로 정하냐는 완전히 자유지만, 일반적으로 한 번에 요구하는 메모리의 크기는 작은 경우가 큰 경우보다 많기 때문에 32,64,96 이런식으로 촘촘하게 하다가 256, 512, 1024 이런 식으로 늘려주는 방식을 택한다)  

메모리풀 자체의 구현 방식은 크게 두가지가 자주 쓰이는데, 일단 큰 메모리를 잡아두고 시작한다는 점은 동일하다.  
방식은 다음과 같다.  
1) [.....................]로 메모리를 잡아두고 [[------][--]........] 이런 식으로 필요한 만큼만 제공하는 방식
2) [...][...][...][...]로 메모리를 잡아두고 얼마가 필요하든 쪼개놓은 공간 하나를 제공하는 방식 (ex. [-..][---][--.][...])

한 번에 할당하거나 해제하는 메모리 크기가 고정적인 2번 방식이 더 구현하기 쉽다.  

## 왜 하는가?
왜 메모리 풀링을 사용하는지를 이해하는 게 중요한데, 메모리 파편화 문제를 막아준다는 점도 있고(이건 2번 방식인 고정 크기 할당 방식으로 구현할 경우 특히 더 장점으로 작용) 커널에 메모리 할당 해제 요청을 반복적으로 하는 무거운 작업을 줄여주고 한번 OS로부터 할당받은 메모리를 자체적으로 재사용해서 성능을 향상시켜준다는 점도 있다.  
이 점을 고려하며 생각해보면, 아주 큰 메모리를 한 번에 할당해야 하는 경우 메모리 풀링이 의미가 없음을 이해할 수 있다. 고로 메모리 풀링을 사용하는게 유리한 경우와 그렇지 않은 경우를 구분해서 사용하면 더 큰 프로그램 성능 개선을 기대할 수 있다.  
요즘은 OS 자체에서 메모리 관리를 잘 해주기 때문에 메모리 풀링을 사용하지 않는 서버들도 있다고 한다.

## 주의
메모리 풀링 정책은 StompAllocator과 호환이 어렵다. 이유는 StompAllocator는 메모리를 할당받고 해제할 때 OS에 요청해 메모리를 완전히 날려버리는 방식인데, 메모리 풀링 정책은 메모리 해제 시 재사용 가능성을 염두에 두고 데이터만 지우고 메모리풀에 보관하는 방식이기 때문이다.  
때문에 전처리기 등을 사용해 디버깅 모드, 즉 메모리릭을 잡아야 하는 경우에는 Stomp를 쓰고 그렇지 않을 때는 메모리풀을 쓰는 등의 방식을 사용할 수도 있겠다. (IOCP 32 참고, 단 영상 코드에서는 시연을 위해 디버그 시 메모리풀을 사용하게 작성중임)  

## 참고
메모리 풀을 사용할 경우 만약 메모리 오염이 발생하면 어떤 절차에서 어떤 메모리를 확보한느 과정에 의해 버그가 발생했는지 찾아내기가 어렵낟. 메모리를 계속 썼다 반환했다 반복하기 때문에 trace하는게 사실상 불가능하다. (물론 할당받은 메모리의 크기정도는 알 수 있지만 크기만으로 이게 코드의 어느 시점에서 요청한 메모리인지를 알기가 쉽지 않다)  
때문에 종종 고려되는게 Object Pool인데, 사실 메모리풀과 거의 동일하고 그냥 특정한 오브젝트에 대해서만 풀링을 해주는 메모리풀이라고 생각하면 된다. 이걸 사용하면 메모리 오염이 발생해도 어떤 오브젝트풀에서 발생했는지를 알 수 있기 때문에 비교적 디버깅이 용이해진다. 다만 클래스 종류별로 오브젝트 풀을 만들어 운영하기 쉽지 않고, 또 코드 전반적인 통일성을 해친다는 점이 단점이다.  
