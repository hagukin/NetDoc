# Stomp Allocator
## 개요
메모리 오염으로 인한 버그를 방지하는데 유용한 기법이다.  
언리얼에서도 제공하는 기능인만큼 보편적으로 사용된다.  

```c++
// 메모리 오염의 아주 간단한 예

// 1. Use after free problem
Player* p1 = new Player();
p1->name = "John";
delete p1;
p1->name = "Tom"; // 메모리 오염! 이미 해제한 메모리를 건드리고 있음에도 크래시가 나지 않는다.
// 만약 해당 위치에 어떤 유효한 데이터가 위치하고 있었다면 이는 정보 손실 등의 끔찍한 결과를 초래할 수 있다.
// 사실 이건 스마트포인터를 활용해서 해결할 수도 있다.

// 2. 벡터 clear 이후 접근
vector<int> v{1,2,3,4,5};
for (int i=0; i<5; ++i)
{
  int val = v[i];
  if (val == 3)
  {
    v.clear();
  }
  doSomething(v[i]); // v가 해제되었을 수도 있음에도 사용중!
}
// 사실 이 예시는 컴파일러에서 잡히긴 하지만 안잡히는 경우도 있을 수 있으므로 위험하다

// 3. 상속 관계에서 발생하는 문제
/*
Entity를 상속한 Actor라는 클래스가 있을 때
Entity* entity;
entity를 actor = static_cast<Actor>(entity)로 형변환 강제로 시킨 이후
actor->actorHp; 식으로 접근할 떄 문제가 발생할 수 있다.
애초에 액터로 형변환하면 안되는 엔티티였을 수도 있기 때문이다.
*/
```

이런 문제는 사실 new와 delete는 어디까지나 c++ 표준이지, 운영체제 단에서 바로 메모리를 할당해주지는 못하기 때문에 발생한다.  
구체적으로 설명하면, (윈도우 기준으로) 만약 윈도우 API에서 메모리 할당 및 해제를 해주는 함수를 직접 호출할 경우 위와 같은 버그가 발생하기 전에 크래시가 난다.  

```
int* test = (int*)::VirtualAlloc(NULL, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); // 자세한건 공식 도큐먼트 참조, 간단히 말해 그냥 4byte의 rw가 가능한 메모리를(위치는 아무데나 알아서 잡아달라고 부탁) 예약 및 할당한다는 뜻이다
*test = 100;
::VirtualFree(test, 0, MEM_RELEASE);
*test = 200; // ---> 크래시!
```

그러나 동일한 로직의 코드를 new, delete를 사용해 구현하면 크래시가 나지 않는다. 즉 메모리 오염이 발생한다!  
```
int* test = new int;
*test = 100;
delete test;
*test = 200; // ---> 크래시 안남! (사실 int로 정확히 지금 이 크도를 실행하면 컴파일러가 잡아주긴 하지만, 만약 int가 아니라 직접 구현한 Player같은 클래스였고 delete 이후 *player->name 이런 멤버변수를 접근했다면 크래시 안나고 그냥 그대로 진행되어 메모리 오염이 발생할 수 있다.)
// 여기서는 편의상 그냥 int로 작성한 것이므로 넘어하자.
```

## 구현
세부적인 구현은 생략, 여기서는 개념만 간단히 정리한다.  
(IOCP 29 참조)  
메모리 할당 및 해제 함수를 직접 구현할 때 해당 OS의 API를 이용해 페이지(윈도우에서는 일반적으로 4kb) 단위로 메모리를 할당하는 방식으로 구현된다.  
이렇게 할 경우 c++의 new와 다르게 크래시가 발생한다. (운영체제 단에서 잡아준다) 즉 메모리 오염을 사전에 감지할 수 있다.  

단점은 페이지를 사용하는 만큼 아주 작은 메모리를 할당할 때도 최소 4kb는 잡아야 한다는 문제가 있으나, 이는 개발 초기에 메모리 오염을 감지할 수 있다는 것을 생각하면 감수할 만한 단점이다.  

아쉬운 점이 없는 건 아닌데, 메모리 overflow 문제를 잡기가 어렵다. 페이지를 사용하는 만큼, 필요한 메모리가 [  ] 인데 [            ]만큼을 잡아버리다보니, [---             ] 이런식으로 앞에 부분만 사용하고 비어버리는 뒷쪽 메모리가 생겨난다. 이때 뒷 메모리에 접근하더라도 하드웨어적으로는 할당한 메모리를 사용하는 것이기 때문에 overflow 감지가 안된다.  
이를 꼼수를 써서 '해결'할 수 있는데, 메모리를 할당하고 값을 집어넣을 때 최대한 메모리 끝쪽으로 붙여 [             ---] 식으로 값을 집어넣으면 --- 다음 칸에 접근하려고 하는 순간 overflow문제가 바로 감지된다.  
(물론 underflow 문제가 발생할 여지는 여전히 남아있지만, 실제로 underflow가 발생하는 경우가 극히 드물다는 점을 생각하면 훨씬 더 나은 방식이다)  





